Phil Calçado 详细的介绍了从开发者视角来看，服务开发模式和Service Mesh技术的演化过程。


时代0：开发人员想象中，不同服务间通信的方式，抽象表示如下：

时代1：原始通信时代

现实远比想象的复杂，通信过程中，我们需求自己处理网络中所面临的丢包、乱序、重试等一系列流控问题。

时代2：TCP时代

TCP协议的出现，避免每个服务实现业务逻辑的同时还要实现一套相似的网络传输处理的逻辑。 来解决网络传输中通用的流量控制问题，将技术栈下移，从服务的实现中抽离出来，成为操作系统网络层的一部分。

时代3：第一代微服务

分布式系统的发展带来了新的问题，如熔断策略、负载均衡、服务发现、认证和授权、quota限制、trace和监控等等，于是由回到上面的问题，在业务实现中又大量的实现了这一些基本功能。

时代4：第二代微服务

为了避免每个服务都要实现一套分布式系统通信的语义功能，一些面向微服务架构的开发框架出现了，如Twitter的Finagle、Facebook的Proxygen以及Spring Cloud等等。 
这些框架实现了分布式系统的一些通用功能：如负载均衡和服务发现等，使得开发人员更加专注于业务的开发。

时代5：第一代Service Mesh

第二代微服务模式看似完美，但开发人员很快又发现，它也存在一些本质问题：

其一，虽然框架本身屏蔽了分布式系统通信的一些通用功能实现细节，但开发者却要花更多精力去掌握和管理复杂的框架本身，在实际应用中，去追踪和解决框架出现的问题也绝非易事；
其二，开发框架通常只支持一种或几种特定的语言，回过头来看文章最开始对微服务的定义，一个重要的特性就是语言无关，但那些没有框架支持的语言编写的服务，很难融入面向微服务的架构体系，想因地制宜的用多种语言实现架构体系中的不同模块也很难做到；
其三，框架以lib库的形式和服务联编，复杂项目依赖时的库版本兼容问题非常棘手，同时，框架库的升级也无法对服务透明，服务会因为和业务无关的lib库升级而被迫升级；

因此以Linkerd，Envoy，为代表的代理模式（SideCar）应运而生，这就是第一代Service Mesh。

它将分布式服务的通信抽象为单独一层，在这一层中实现负载均衡、服务发现、认证授权、监控追踪、流量控制等分布式系统所需要的功能，作为一个和服务对等的代理服务，和服务部署在一起，接管服务的流量，通过代理之间的通信间接完成服务之间的通信请求，这样上边所说的三个问题也迎刃而解。

时代6：第二代Service Mesh

第一代Service Mesh由一系列独立运行的单机代理服务构成，为了提供统一的上层运维入口，演化出了集中式的控制面板，所有的单机代理组件通过和控制面板交互进行网络拓扑策略的更新和单机数据的汇报。这就是以Istio为代表的第二代Service Mesh。


我们再回过头来看Buoyant的CEO William Morgan，也就是Service Mesh这个词的发明人，对Service Mesh的定义：

服务网格是一个基础设施层，用于处理服务间通信。云原生应用有着复杂的服务拓扑，服务网格保证请求在这些拓扑中可靠地穿梭。在实际应用当中，服务网格通常是由一系列轻量级的网络代理组成的，它们与应用程序部署在一起，但对应用程序透明。

有四个关键词：

基础设施层+请求在这些拓扑中可靠穿梭：这两个词加起来描述了Service Mesh的定位和功能。

网络代理：这描述了Service Mesh的实现形态；

对应用透明：这描述了Service Mesh的关键特点，正是由于这个特点，Service Mesh能够解决以Spring Cloud为代表的第二代微服务框架所面临的三个本质问题；
-------------------------------------


为了最大限度地缓解以上问题，Istio的工程师们想出了一个思路：将架构重心尽量向中心倾斜，即将逻辑统一地放置了在Mixer中，数据平面仅仅是做简单的转发。

对于Mixer缓存的设计，也有人持不同的观点。蚂蚁金服的工程师们就认为Mixer的中心化设计也不能完全满足其生产场景，主要原因便是存在流量集中的现象，即由于中心节点Mixer的存在，链路的认证、鉴权、统计等信息都需要请求中心来实现，在大规模微服务体系中，确实有很大的吞吐量压力。

蚂蚁金服的工程师们为了规避上述问题，将Mixer的部分逻辑（比如内存、Redis配额逻辑）移到了Sidecar中（蚂蚁金服使用的Sidecar并不是官方的Envoy），如图2.3所示。这确实可以大幅度提高性能，不过可就与Istio的设计哲学有些冲突了，所以各有取舍
