<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="author" content="xyecho" />
    <title>TCP协议杂记</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <link href="/feed/" rel="alternate" title="xyecho" type="application/atom+xml" />
    <link rel="stylesheet" href="/media/css/style.css" />
    <link rel="stylesheet" href="/media/css/highlight.css" />
    <script type="text/javascript" src="/media/js/jquery-1.7.1.min.js"></script>
  </head>
  <body>
    <div id="container">
      <div id="main" role="main">
        <header>
        <h1>TCP协议杂记</h1>
        </header>
        <nav>
        <span><a title="网站首页" class="" href="/">首页</a></span>
        <span><a title="文章分类" class="" href="/categories/">分类</a></span>
        <span><a title="标签索引" class="" href="/tags/">标签</a></span>
        <!--<span><a title="友情链接" class="" href="/links/">链接</a></span>-->
        <span><a title="留言交流" class="" href="/guestbook/">留言</a></span>
        <span><a title="关于站长" class="" href="/about/">关于</a></span>
        <span><a title="种子订阅" class="" href="/feed/" target="_blank">订阅</a></span>
        </nav>
        <article class="content">
        <section class="meta">
<span class="time">
  <time datetime="2014-10-15">2014-10-15</time>
</span>

 | 
<span class="categories">
  分类
  
  <a href="/categories/#Linux" title="Linux">Linux</a>&nbsp;
  
</span>


 | 
<span class="tags">
  标签
  
  <a href="/tags/#network" title="network">network</a>&nbsp;
  
</span>

</section>
<section class="post">
<p>从四个方面来理解TCP协议
1 TCP头部信息
2 TCP 状态转移过程
3 TCP 数据流
4 TCP数据流的控制</p>

<p>TCP为什么叫数据流：应用程序对数据的发送和接收是没有边界限制的。
TCP为什么是可靠的：TCP协议采用发送应答机制，即发送端发送的每个TCP报文段都必须得到接收方的应答，其次，采用超时重传机制。</p>

<p>UDP虽然说是不可靠服务，但是可以在上层协议来处理数据确认和超时重传。</p>

<p>** TCP 固定头结构: **</p>

<p><img src="/assets/network/tcp-base-1.png" alt="" /></p>

<p>16位端口号：告知这个报文来自那个源端口和给上层协议或者应用那个目的端口。（注意IP是在IP协议层里的）
32位序号：一次TCP通信（从TCP连接到断开）过程中某一个传输方向上的字节流的每个字节编号。
32位确认号：用作对另一方发送来的TCP报文的响应。
4位头部长度：标识该TCP头部多少个32bit字（4字节）因为4位最大能表示15，所以TCP头最长60字节。（15*4=60）
6位标志们包含好下：
（1）URG 表示紧急指针是否有效
（2）ACK 表示确认号是否有效
（3）PSH 提示接收端应用程序应该即人TCP接收缓冲区中读走数据，为接收后续数据腾出空间。
（4）RST 表示要求对方重新连接。
（5）SYN 表示请求建立一个连接。
（6）FIN 表示通知对方本端村关闭连接。</p>

<p>16位窗口大小:是TCP流量控制的一个手段。它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。
16位校验和：同发送方填充。用CRC对数据作检验，这个校验不肥包括TCP头部，也包括数据部分，TCP可靠传输的一个生要保障。
16位紧急指针：是一个正的偏移量，它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。
TCP头部选项：这部分最后含有40字节。
kind=0：选项表结束选项
kind=1：空操作（nop）选项
kind=2：最大报文段长度选项，TCP模块通常将MSS设置为（MTU-40）字节（减掉的这40字节包括20字节 的TCP头部和20字节的IP头部）对以太网而言，MSS值是1460（1500-40）
kind=3：窗口扩大因子选项 。窗口扩大因了选项只能出现在同步报文段中。
kind=4：选择性确认 。使TCP模块只能重新发送丢失的TCP报文段、不用发送所有未被确认的 TCP报文段。
kind=5：SACK实际工作的选项
kind=8    时间戳选项 提供较为准确的计算通信双方之间的回路时间的方法。</p>

<p><strong>半关闭状态</strong></p>

<p>TCP 连接是全双工的，所以它允许两个方向的数据传输被独立关闭，通信的一端可艰送结束报文给对方，告诉它本端已经完成了数据的发送。但允许继续接收来息对方的数据 ，直到对方也发送结束报文段以关闭连接。TCP连接的这种状态称为半关闭状态。
服务器和客户端应用程序 判断对方是否已经关闭连接的方法是：read系统调用返回0（收到结束报文段）。
socket网络编程接口通过shutdown函数提供了对阗关闭的支持。</p>

<p>连接超时 ~~</p>

<p><strong>三次握手 四次挥手:</strong></p>

<p><img src="/assets/network/tcp-base-2.png" alt="" /></p>

<p>TIME_WAIT状态
从图可以看，客户端连接在收到 服务器的结束报文段之后，并没有直接进入 CLOSED状态，而是转移到TIME_WAIT状态。在这个状态，客户端连接要等待一段时间为2MSL的时间。才能完全关闭。
MSL是TCP报文段在刚和　的最大生存时间。</p>

<p><strong>TIME_WAIT状态存在的原因有两点:</strong> 
1）可靠地终止TCP连接
2）保证让发来的TCP报文段有足够的时间被识别并丢弃。</p>

<p>第一个原因：用于确认服务器结束报文段６和报文段７丢失。那么服务器重发结束报文段。因此客户端需要停留在某个以处理重复收到的结束报文段（即向服务器发送确认报文段）
第二个原因：在linux系统上，一个TCP端口不能被同时打开多次（两次及以上）。当一个TCP连接处于TIME_WAIT状态时。我们将无法立即使用该连接占用着的端口来建立一个连接。如果不存在TIME_WAIT，则应用程序程序能够立即建立一个和刚关闭的连接相似的连接（同IP地址和端口号）这个新连接被称了连接的化身。它可能会接收到属于原来的连接的应用程序数据。这是不应该发的事。  <br />
另外，历为TCP报文段的最大生存时间是MSL,所以坚持 2M  SL时间的TIME_WAIT状态能够确保网络上两具传输方向上接收到的、迟到的TCP报文都已经消失。因此一个新连接可能在2MSL时间后安全地建立。</p>

<p>复位报文段
在某些特殊条件下，TCP连接的一端会向另一端发送携带RST标志的报文段，即复位报文段。</p>

<p>异常终止连接
TCP提供了异常终止一个连接的方法，即给对方发送一个复位报文段。一旦发送了复位报文段，发送端所有排除等待的数据都将被丢弃。</p>

<p>处理半打开连接
服务器（或客户端）关闭或者异常终止了连接，而对方没有接收到结束报文段（比如发生了网络故障），此时，客户端（或服务端）还维持着原来的连接，而服务器（或客户端）即使重启，也已经没有该连接的任何信息了。我们将这种状态称为打开状态，处于这种连接称为半找连接。如果客户端（或服务器）往处于阗打开连接写入数据，则对方方将回应一个复位报文段。</p>

<p>TCP交互数据流
TCP报文段所携带的应用程序数据按照长度分为两种：交互数据和成块数据。交互灵气公包含很少的字节。使用交互数据的应用程序（或协议）对实时性求高。如telnet、ssh。成块数据的长度则通常用TCP报文段允许的最大数据长度。使用成块数据的应用程序 （协议）对传输效率要求高，如ftp。</p>

<p>带外数据
带外数据用于迅速通知对方本端发生的重要事件。因此，带外数据比普通数据（也称为带内数据）表更高的优先级。它应该总是立即被发送，而不论发送缓冲区中是否有排队等待发送的普通数据。
UDP没有实现带外数据传输，TCP也没有真正的带外数据。不过TCP利用其头部中的紧急指针标志和紧急指针两个字段，给应用程序提供了一种紧急方式 。</p>

<p>TCP超时重传
TCP服务必须能够重传超时间内未收到确认的TCP报文段。为此， TCP报文段都维护一个重传定时器，该定时器在TCP报文段第一次被发送时启动。如果超时时间内未收到接收方的应答，TCP模块将重传TCP报文段并重置定时器。至于下次重传的超时时间如何选择，以及最多执行多少次重传，就是TCP的重传策略。一共会执行5次重传。次数可以系统相关配置更改。/proc/sys/net/ipv4/tcp_retries1和/proc/sys/net/ipv4/tcp_retries2 前者指定 在底IP接管之前TCP最少执行的重传次数，默认值是３，后者指定 连接放弃前TCP最多可以执行的重传次数，默认值是15。</p>

<p>拥塞控制
TCP拥塞控制的四个部分：慢启动、拥塞避免、快速重传、快速恢复、快速恢复。</p>


</section>
<section align="right">
<br/>
<span>
	<a  href="/epoll-lt-et/" class="pageNav"  >上一篇</a>
	&nbsp;&nbsp;&nbsp;
	<a  href="/linux-gdb/" class="pageNav"  >下一篇</a>
</span>
</section>
<!-- JiaThis Button BEGIN -->
<script type="text/javascript">
var jiathis_config = {data_track_clickback:'true'};
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jiathis_r.js?move=0&amp;uid=2121774" charset="utf-8"></script>
<!-- JiaThis Button END -->


	
	<div class="ds-thread" />
		
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"xyecho"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = 'http://static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		|| document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>


<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fc91691cf4004b194f7847896cca17dbb' type='text/javascript'%3E%3C/script%3E"));
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-56673760-1', 'auto');
  ga('send', 'pageview');

</script>

        </article>
      </div>

    <footer>
        <p>
          <script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fc91691cf4004b194f7847896cca17dbb' type='text/javascript'%3E%3C/script%3E"));
</script>

          <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-56673760-1', 'auto');
  ga('send', 'pageview');

</script>
        </p>
        <p><small>
            <a href="http://github.com/CarlosFang/CarlosFang.github.io/new/gh-pages/_posts" target="_blank" title="撰写文章">Po</a>wer<a href="http://github.com/CarlosFang/CarlosFang.github.io/edit/gh-pages/_posts/2014-10-15-tcp-base.md" target="_blank" title="编辑页面">ed</a> by <a href="http://jekyllrb.com" target="_blank">Jekyll</a> @ <a href="http://github.com/CarlosFang/CarlosFang.github.io" target="_blank" title="项目主页">GitHub</a>
             | <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/cn/" target="_blank" title="许可协议">©</a> 2014 - 2017 <a href="/about/">xyecho</a>
             | <a href="http://blog.xyecho.com" target="_blank">@cnblogs</a>


         </small></p>
    </footer>

    </div>
  </body>
</html>
