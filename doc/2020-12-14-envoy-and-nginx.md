

Envoy 与 Nginx 架构层面的对比

 刘俊海 《service mesh 微服务架构设计》 京东：https://item.jd.com/12730788.html

第4章 6节  笔记 时间： 2020-12-01

Nginx是Envoy出现之前网络通信中间件领域非常有代表性的开源系统，功能强大，性能出色，扩展性很强，已经形成了强大的生态，成为HTTP流量管理领域事实上的标杆。

### 功能与定位

Nginx最核心的功能是Web服务器和反向代理服务器，Web服务器完成对HTTP请求协议的解析和以HTTP协议格式响应请求、缓存、日志处理这些基本Web服务器功能；
反向代理服务器完成对请求的转发、负载均衡、鉴权、限流、缓存、日志处理等代理常用功能。

Envoy定位是透明接管微服务之间的通信流量，将通信和服务治理功能从微服务中解耦，通过Envoy可以方便地增加对自定义协议的支持。

Nginx的关键词是Web服务器和反向代理，Envoy是透明接管流量，更加体现对流量的控制和掌控力。

微服务对Nginx是显式调用，通过Nginx完成负载均衡等相关功能，对Envoy是隐式调用，业务微服务不需要感知Envoy的存在，和使用Envoy使用相同的方式进行通信，只不过不再需要关注通信和链路治理的细节。

### 网络模型

Nginx采用的是经典的多进程架构，由master进程和worker进程组成。

其中，master进程负责对worker进程进行管理，具体包含监控worker进程的运行状态，根据外部输入的一些管理命令向worker进程发送处理信号以及worker进程退出时启动新的worker进程。

worker进程负责处理各种网络事件，各个worker进程之间相互独立，一同竞争来自客户端的新的连接和请求，为了保证请求处理的高效，一个请求处理的全部过程在同一个worker进程中。

worker进程的个数推荐配置为与当前环境的CPU核数相同。

Envoy采用了多线程的网络架构，Envoy一般会根据当前CPU核数创建相同个数的worker线程，所有worker线程同时对Envoy配置的监听器进行监听，接受新的连接，为每个新连接实例化相应的过滤器处理链，处理该连接上的所有请求。和Nginx类似，Envoy的每个请求的处理全流程都在同一个线程下进行。

Envoy和Nginx的网络处理方式大体类似。这两种方式都是全异步的编程模式。 Envoy和Nginx的网络处理方式大体类似。这两种方式都是全异步的编程模式

### 解决进程或线程卡住问题

请求处理过程中如果遇到特别耗时的操作，比如磁盘访问、第三方服务同步访问等，会导致处理该请求的进程被夯住，不仅CPU资源没有得到充分利用，夯住时间比较长时不仅会影响当前请求，严重时会导致本进程的待处理请求大量超时。为了解决这种问题，

Nginx从1.7.11版本开始引入了线程池的概念，如果遇到耗时特别长的逻辑，可以增加线程池配置，放到线程池中进行处理。线程池机制的引入对Nginx架构来说是个很好的补充，通过针对性地解决耗时特别长的一些阻塞场景，使得Nginx的性能达到一个新的高度。

为每个worker线程分别设置一个看门狗，并通过定时器定期更新本线程看门狗的最新更新时间，主线程会监控各个worker线程看门狗一段时间内是否有更新，如果超过一段时间没有更新，可以认为该线程的看门狗定时更新操作得不到执行的机会，从而推断出这个线程当前已经夯住，无法处理请求消息。Envoy通过这种机制可以检测出worker线程是否被长时间阻塞住，在此机制的基础上，后续可以增加相应的处理（比如将待处理请求移到其他线程，然后把该线程杀掉），可以从机制上解决工作线程被阻塞的问题。

Envoy的解决方式是：为每个worker线程分别设置一个看门狗，并通过定时器定期更新本线程看门狗的最新更新时间，主线程会监控各个worker线程看门狗一段时间内是否有更新，如果超过一段时间没有更新，可以认为该线程的看门狗定时更新操作得不到执行的机会，从而推断出这个线程当前已经夯住，无法处理请求消息。Envoy通过这种机制可以检测出worker线程是否被长时间阻塞住，在此机制的基础上，后续可以增加相应的处理（比如将待处理请求移到其他线程，然后把该线程杀掉），可以从机制上解决工作线程被阻塞的问题。

#### 连接处理

Nginx通过worker_connections参数来控制每个worker能够建立的最大连接数。

户端连接到来时，所有空闲的进程都会去竞争这个新连接。

不同连接上可能承载的请求QPS差异很大，可能会出现两个进程处理相同连接数，但一个特别忙另外一个特别闲的现象，因此为了保证各个工作进程都能够最大限度地提供自己的计算能力，需要对连接进行精细化管理。 

Nginx采取的方式是各工作进程根据自身的忙闲程度，动态调整获取新连接的时机，具体实现是：当本进程当前连接数达到最大worker_connections的7/8时，本worker进程不会去试图拿accept锁，也不会去处理新连接，这样其他worker进程就更有机会去处理监听句柄，建立新连接。

Envoy没有解决负载不均问题。

### 插件机制

Nginx对模块的支持总体来说不算灵活，Nginx模块必须和Nginx自身源码一块编译，并且只能在编译期间选择当前支持的模块，不支持运行时进行模块动态选取和加载，大家一直以来吐槽比较多。为了解决这个问题，Nginx在1.9.11版本引入了模块动态加载支持，从此不再需要替换Nginx文件即可增加第三方模块扩展。

Nginx也支持Lua扩展，利用Lua语言的简单易用和强大的协程机制，可以非常方便地实现很多扩展机制，并且性能也能够基本满足需求。

Envoy的插件当前采用的是静态注册的方式。

Envoy从最开始就支持插件的动态加载，Envoy通过独特的XDS API设计，可以随时对Envoy的XDS插件进行定制修改，Istio将修改后的XDS配置通过Grpc的方式推送给Envoy动态加载和生效。

Cilium从1.3版本开始，引入了Envoy的Go扩展，通过Go扩展实现Filter插件向Envoy注册，主要实现的还是OnData()函数，当Envoy接收到流量时，就会调用插件的

### 配置管理

Nginx的配置格式使用自定义的方式，配置结构和配置解析过程都非常复杂。

Envoy的配置管理部分设计得就比较优雅，配置格式直接使用了Protobuf 3，复用了Protobuf 3的数据描述能力和自动代码生成机制，完全省去了配置解析的过程，并且也非常方便对配置格式的有效性进行验证。

Nginx的配置都是静态配置，不支持任何形式的动态配置能力。动态配置能力是Envoy相比Nginx最核心的竞争力，通过动态配置，可以在线修改流量路由和链路治理策略，实现策略配置修改的即时生效。

### 内存管理

Nginx内存管理通过Nginx内存池实现，通过内存池的良好设计，使用内存池进行内存管理时，不需要关注内存什么时候释放，连接销毁时会回收连接对应的内存资源；同时通过内存池可以减少内存碎片，通过内存对齐、内存分页等机制，可以有效减少缓存未命中（Cache Miss），提高内存访问的效率。

Envoy在内存管理方面的支持还很粗糙，直接基于原生的内存管理库，内存释放时机管理通过智能指针管理内存的生命周期。

### 部署与运维

Envoy是通过控制平面组件Pilot Agent和Sidecar-injection进行管理，Pilot Agent负责管理Envoy的运行状态，当Envoy状态有问题时，Pilot Agent会将Envoy重启，如果重启仍然不能解决问题，会尝试将Envoy调度到其他环境下；Sidecar-injection负责Envoy的自动注入。

### 观测与诊断

从服务的可观测以及诊断上说，Envoy投入了大量的精力，已经全面支持Log、Metric、Trace等可观测机制，并且每种观测方式均提供相应的扩展机制，Nginx在这方面相对逊色很多。