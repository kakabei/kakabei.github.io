---
layout: post
title: muduo笔记 第二章 线程同步精要
date: 2018-01-03 18:08:12
categories: Linux muduo
tags: 系统编程 muduo tcp network thread
excerpt: 线程同步的要点
---

#### 二 不要用读写锁和信号量

理由是什么？

##### 读写锁

1.在后期的维护阶段，程序员可能在读的状态(read lock)写入共享数据。

2.从性能方面，读写锁并没有比mutex高效多少。如果临界区很小，锁竞争不是很激烈。mutex可能会更好。

3.通常read lock是可重入。writer lock是不可重入。但是为了防止writer饥饿，writer lock通常会阻塞后来的reader lock，因此reader lock在重入的时候可能死锁。

##### 信号量

1.条件变量配合互斥器可以完全替代信号量。

2.信号量的另一个问题在于它有自己的计数值，而通常我们自己的数据结构也有长度值，这就造成了同样的信息存了两份，需要时刻保持一致，这增加了程序员的负担和出错的可能。

3.信号量允许多个线程同时进入临界区。

#### 三　线程安全的Singleton实现

一开始一度认为double checked locking是王道。但后来有人指出由于乱序执行的影响，DCL是靠不住的。

在实践中运用pthread_once就可以了。c++11 中用std::call_once （pthread_once单例模式）

#### 四　sleep(3)不是同步原语
sleep()/usleep()/nanosleep()只能出现在测试代码中，比如写单元测试的时候 ；或者用于有意延长临界区，加速复现死锁的情况。

sleep不具备memory barrier（内存屏障）语义，它不能保证内存的可见性。 

在程序的正常执行中，如果需要等待一段已知的时间，应该往event loop里注册一个timer，然后在timer的回调函数里接着干活，因为线程是个珍贵的共享资源，不能轻易浪费（阻塞也是浪费）。如果等待某个事件发生，那么应该采用条件变量或IO事件回调，不能用sleep来轮询。

如果多线程的安全性和效率要靠代码主动调用sleep来保证，这显然是设计出了问题。等待某个事件发生，正确的做法是用select()等价物或Condition，抑或（更理想地）高层同步工具；在用户态做轮询（polling）是低效的。

#### 五　总结

线程同步的原则

- 尽量用高层同步设施（线程池、队列、倒计时） 
- 使用普通互斥器和条件变量完成剩余的同步任务，
- 采用RAII惯用手法（idiom）和Scoped Locking。
 
用好这几样东西，基本上就能应付多线程服务端开发的各种场合。或许有人会觉得性能没有发挥到极致。我认为，应该先把程序写正确（并尽量保持清晰和简单），然后再考虑性能优化，如果确实还有必要优化的话。这在多线程下仍然成立。让一个正确的程序变快，远比"让一个快的程序变正确"容易得多。
