---
layout: post
title: mysql InnoDB 引擎
date: 2015-05-24 11:08:12
categories: db
tags:  mysql 
excerpt: InnoDB 引擎是 mysql 的默认引擎。
---


# 一、概述

InnoDB 是一个事务安全的存储引擎，它具备提交、回滚以及崩溃恢复的功能以保护用户数据。

InnoDB 的**行级别锁定**保证数据一致性提升了它的多用户并发数以及性能。

InnoDB 将用户数据存储在**聚集索引**中以减少基于主键的普通查询所带来的 I/O 开销。为了保证数据的完整性。

InnoDB 还支持外键约束。默认使用B+TREE数据结构存储索引。

# 二、特点

1、 支持事务，支持4个事务隔离（ACID）级别。

2、行级锁定，更新时锁定当前行。

3、读写阻塞与事务隔离级别相关。

4、既能缓存索引又能缓存数据。

5、支持外键。

6、InnoDB更消耗资源，读取速度没有MyISAM快。

 7、在InnoDB中存在着缓冲管理，通过缓冲池，将索引和数据全部缓存起来，加快查询的速度。
 
8、对于InnoDB类型的表，其数据的物理组织形式是聚簇表。所有的数据按照主键来组织。数据和索引放在一块，都位于B+数的叶子节点上；

# 三、业务场景

1、需要支持事务的场景。

2、适合高并发，行级锁定对高并发有很好的适应能力，但需要确保查询是通过索引完成的。

3、数据修改较频繁的业务。

# 四、InnoDB引擎调优

1、主键尽可能小，否则会给 Secondary index 带来负担。

2、避免全表扫描，这会造成锁表。

3、尽可能缓存所有的索引和数据，减少IO操作。

4、避免主键更新，这会造成大量的数据移动。


# 五、事务（ACID）

**A 事务的原子性(Atomicity)** 

指一个事务要么全部执行,要么不执行。也就是说一个事务不可能只执行了一半就停止了。

**C 事务的一致性(Consistency)**

指事务的运行并不改变数据库中数据的一致性。 例如： 完整性约束了a+b=10,一个事务改变了a,那么b也应该随之改变。  

**I 独立性(Isolation）** 

事务的独立性也有称作隔离性，是指两个以上的事务不会出现交错执行的状态。因为这样可能会导致数据不一致。

**D 持久性(Durability）**

事务的持久性是指事务执行成功以后,该事务所对数据库所作的更改便是持久的保存在数据库之中，不会无缘无故的回滚。

# 六、InnoDB数据存储结构

### 数据库磁盘读取与系统磁盘读取

1、系统从磁盘中读取数据到内存时是以磁盘块（block）为基本单位，位于同一个磁盘块中的数据会被一次性读取出来。

2、 InnoDB 存储引擎中有页（Page）的概念，页是数据库管理磁盘的最小单位，InnoDB 存储引擎中默认每个页的大小为 16kb，每次读取磁盘时都将页载入内存中。

3、系统一个磁盘块的大小空间往往没有16kb这么大，因此 InnoDB 每次 io 操作时都会将若干个地址连续的磁盘块的数据读入内存，从而实现整页读入内存。

4、InnoDB 数 据存储结构可以划分为逻辑存储结构和物理存储结构。

### 物理存储结构

从物理意义上来看，InnoDB 表由**共享表空间**、**日志文件组**（更准确地说，应该是Redo文件组）、**表结构定义文件**组成。

若将 innodb_file_per_table 设置为 on，则每个表将独立地产生一个表空间文件，以ibd结尾，数据、索引、表的内部数据字典信息都将保存在这个单独的表空间文件中。表结构定义文件以frm结尾，这个是与存储引擎无关的，任何存储引擎的表结构定义文件都一样，为.frm文件。

### 逻辑存储结构

InnoDB 存储引擎的逻辑存储结构和 Oracle 大致相同，所有数据都被逻辑地存放在一个空间中。我们称之为**表空间**。表空间又由**段**、**区**、**页**组成。


InnoDB存储引擎的逻辑存储结构大致如图所示：

![](/assets/db/mysql-2022-09-26_15-23-26.png)


## 6.1 表空间（tablespace）

表空间可以看做是 InnoDB 存储引擎逻辑结构的最高层，所有的数据都是存放在表空间中。

默认情况下 InnoDB 存储引擎有一个共享表空间 `ibdata1`，即所有数据都放在这个表空间内。如果我们启用了参数`innodb_file_per_table`，则每张表内的数据可以单独放到一个表空间内。

对于启用了 `innodb_file_per_table` 的参数选项，需要注意的是，每张表的表空间内存放的只是**数据、索引和插入缓冲**，其他类的数据，如撤销（Undo）信息、系统事务信息、二次写缓冲（double write buffer）等还是存放在原来的共享表空间内。

这也就说明了另一个问题：即使在启用了参数 `innodb_file_per_table` 之后，共享表空间还是会不断地增加其大小。

## 6.2 段（segment）

表空间是由各个段组成的，常见的段有：**数据段**、**索引段**、**回滚段**等。

InnoDB 存储引擎表是由 索引组织的（index organized），因此数据即索引，索引即数据。InnoDB采取**B+树**作为存储数据的结构，**数据段即为B+树的叶节点**（上图的 leaf node segment），索引段即为B+树的非叶子节点（上图的 non-leaf node segment）。

InnoDB 存储引擎对于段的管理是由引擎本身完成。

## 6.3 区（extent）

一个区是由64个连续的页组成的，每个页大小为 16KB，即每个区的大小为 1MB。对于大的数据段，InnoDB存储引擎最多每次可以申请4个区，以此来保证数据的顺序性能。

在我们启用了参数 `nodb_file_per_talbe` 后，创建的表默认大小是 96KB，新建的 InnoDB 表就是一个区。

区是64个连续的页，那创建的表的大小至少是1MB才对啊？其实这是因为在每个段开始时，先有32个页大小的碎片页（fragment page）来存放数据，当这些页使用完之后才是64个连续页的申请。

## 6.4 页（page）

每个页大小为16KB，页是 InnoDB 磁盘管理的最小单位，整页整页的读取。

InnoDB 中主要的页类型：

1、数据页（BTreeNode）

2、Undo页（undo Log page）

3、系统页（System page）

4、事务数据页（Transaction SystemPage）



---
1、[MySQL体系构架、存储引擎和索引结构](https://zhuanlan.zhihu.com/p/500250022)