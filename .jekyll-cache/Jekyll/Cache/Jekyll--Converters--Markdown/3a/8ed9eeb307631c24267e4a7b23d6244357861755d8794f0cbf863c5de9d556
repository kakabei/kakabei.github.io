I"<p>1、 <code class="language-plaintext highlighter-rouge">const</code> 修饰成员变量，定义成 <code class="language-plaintext highlighter-rouge">const</code> 常量，相较于宏常量，可进行类型检查，节省内存空间，提高了效率。</p>

<p>2、 <code class="language-plaintext highlighter-rouge">const</code> 修饰函数参数，使得传递过来的函数参数的值不能改变。</p>

<p>3、 <code class="language-plaintext highlighter-rouge">const</code> 修饰成员函数，使得成员函数不能修改任何类型的成员变量（ <code class="language-plaintext highlighter-rouge">mutable</code> 修饰的变量除外），也不能调用非 <code class="language-plaintext highlighter-rouge">const</code> 成员函数，因为非 <code class="language-plaintext highlighter-rouge">const</code> 成员函数可能会修改成员变量。</p>

<p>4、<code class="language-plaintext highlighter-rouge">define </code>和 <code class="language-plaintext highlighter-rouge">const</code> 的区别：</p>

<ul>
  <li>编译阶段：<code class="language-plaintext highlighter-rouge">define</code> 是在编译预处理阶段进行替换，<code class="language-plaintext highlighter-rouge">const</code> 是在编译阶段确定其值。</li>
  <li>安全性：<code class="language-plaintext highlighter-rouge">define</code> 定义的宏常量没有数据类型，只是进行简单的替换，不会进行类型安全的检查；<code class="language-plaintext highlighter-rouge">const</code> 定义的常量是有类型的，是要进行判断的，可以避免一些低级的错误。</li>
  <li>内存占用：define 定义的宏常量，在程序中使用多少次就会进行多少次替换，内存中有多个备份，占用的是代码段的空间；<code class="language-plaintext highlighter-rouge">const</code> 定义的常量占用静态存储区的空间，程序运行过程中只有一份。</li>
  <li>调试：define 定义的宏常量不能调试，因为在预编译阶段就已经进行替换了；<code class="language-plaintext highlighter-rouge">const</code> 定义的常量可以进行调试。</li>
</ul>

<p>5、 <code class="language-plaintext highlighter-rouge">const</code> 的优点：</p>
<ul>
  <li>有数据类型，在定义式可进行安全性检查。</li>
  <li>可调试。</li>
  <li>占用较少的空间。</li>
</ul>

<p>6、<code class="language-plaintext highlighter-rouge">define</code> 和 <code class="language-plaintext highlighter-rouge">typedef</code> 的区别：</p>

<ul>
  <li>原理：<code class="language-plaintext highlighter-rouge">#define</code> 作为预处理指令，在编译预处理时进行替换操作，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。<code class="language-plaintext highlighter-rouge">typedef</code> 是关键字，在编译时处理，有类型检查功能，用来给一个已经存在的类型一个别名，但不能在一个函数定义里面使用 <code class="language-plaintext highlighter-rouge">typedef</code> 。</li>
  <li>功能：<code class="language-plaintext highlighter-rouge">typedef</code> 用来定义类型的别名，方便使用。<code class="language-plaintext highlighter-rouge">#define</code> 不仅可以为类型取别名，还可以定义常量、变量、编译开关等。</li>
  <li>作用域：<code class="language-plaintext highlighter-rouge">#define</code> 没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而 <code class="language-plaintext highlighter-rouge">typedef</code> 有自己的作用域。</li>
</ul>

<p>7、用宏实现比较大小，以及两个数中的最小值</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#define MAX(X, Y) ((X)&gt;(Y)?(X):(Y))
#define MIN(X, Y) ((X)&lt;(Y)?(X):(Y))
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">var1</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">var2</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">MAX</span><span class="p">(</span><span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">MIN</span><span class="p">(</span><span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
程序运行结果：
100
10
*/</span>
</code></pre></div></div>
:ET